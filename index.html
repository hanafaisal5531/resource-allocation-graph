<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resource Allocation Graph Deadlock Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // High Contrast Dark Theme Palette (Based on user request)
                        'bg-dark': '#020617',        // Primary Background (Near Black)
                        'card-dark': '#020b2a',      // Panels/Visualization background (Deep Blue)
                        'sub-card': '#1e293b',       // Metrics/List Background (Visible Separators)
                        'border-color': '#1e293b',   // Stronger Borders
                        
                        // Node Colors (Bright for High Contrast)
                        'process-color': '#E5E7EB',  // Light Gray (New Process Color)
                        'resource-color': '#60A5FA', // Vivid Blue (New Resource Color)
                        'deadlock-color': '#ef4444', // Red-500 (Brighter Deadlock highlight)
                        
                        // Edge Colors (Vivid)
                        'request-edge': '#facc15',   // Yellow-400
                        'allocation-edge': '#34d399',// Emerald-400
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom styles for the SVG visualization */
        .rag-container {
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }
        .node-circle, .node-rect {
            transition: fill 0.3s, stroke 0.3s;
        }
        .edge-path {
            transition: stroke 0.3s, stroke-width 0.3s;
            stroke-linecap: round;
        }
        
        /* Custom scrollbar for better look in dark theme */
        .scrollable-content::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        .scrollable-content::-webkit-scrollbar-thumb {
            background-color: #374151; /* Darker thumb */
            border-radius: 5px;
            border: 2px solid #020b2a; /* Border matching the panel background */
        }
        .scrollable-content::-webkit-scrollbar-track {
            background: #020b2a;
        }
    </style>
</head>
<body class="bg-bg-dark flex flex-col items-center p-6 min-h-screen font-sans text-slate-200">
    <header class="text-center mb-8 w-full max-w-6xl">
        <h1 class="text-4xl font-extrabold text-white">Resource Allocation Graph (RAG) Simulator</h1>
        <p class="text-slate-400 mt-2">Visualize processes, resources, and analyze deadlocks using DFS Cycle Detection. Drag nodes to rearrange the graph!</p>
        <div id="deadlock-status" class="mt-5 p-4 font-semibold rounded-xl shadow-2xl bg-green-900 text-green-300 border border-green-700">
            System Status: SAFE (No Deadlock)
        </div>
    </header>

    <main class="w-full max-w-6xl flex flex-col lg:flex-row gap-6">
        <!-- Controls Panel (Wider on desktop for metrics) -->
        <div class="lg:w-2/5 bg-card-dark p-6 rounded-xl shadow-2xl h-full border border-border-color">
            <h2 class="text-2xl font-bold mb-4 text-white">Simulation Metrics</h2>

            <!-- Simulation Metrics Tiles -->
            <div id="metrics-panel" class="grid grid-cols-2 gap-3 mb-6 p-3 bg-sub-card rounded-lg border border-border-color">
                <!-- Metrics will be inserted here by JavaScript -->
            </div>

            <h2 class="text-2xl font-bold mb-4 text-white border-t border-border-color pt-4">Manage Edges</h2>

            <!-- Edge Management Form -->
            <div class="space-y-4 mb-6">
                <div class="flex gap-4">
                    <div class="flex flex-col flex-1">
                        <label for="source" class="text-sm font-medium text-slate-300 mb-1">Source Node:</label>
                        <select id="source" class="p-2 border border-border-color bg-sub-card text-white rounded-lg focus:ring-process-color focus:border-process-color"></select>
                    </div>

                    <div class="flex flex-col flex-1">
                        <label for="target" class="text-sm font-medium text-slate-300 mb-1">Target Node:</label>
                        <select id="target" class="p-2 border border-border-color bg-sub-card text-white rounded-lg focus:ring-process-color focus:border-process-color"></select>
                    </div>
                </div>

                <div class="flex gap-2">
                    <button onclick="createRequest()" class="flex-1 py-2 bg-request-edge text-gray-900 font-bold rounded-lg hover:bg-yellow-500 transition duration-150 shadow-md">
                        Request (P → R)
                    </button>
                    <button onclick="createAllocation()" class="flex-1 py-2 bg-allocation-edge text-gray-900 font-bold rounded-lg hover:bg-teal-500 transition duration-150 shadow-md">
                        Allocate (R → P)
                    </button>
                </div>
                <button onclick="removeEdge()" class="w-full py-2 bg-sub-card text-white font-medium rounded-lg hover:bg-slate-700 transition duration-150 shadow-md border border-border-color">
                    Remove Edge (Source ↔ Target)
                </button>
            </div>
            
            <div id="action-message" class="text-center text-sm p-2 rounded-lg mt-3 transition-opacity duration-300 opacity-0"></div> 
            
            <h3 class="text-xl font-semibold mb-3 text-white border-t border-border-color pt-4">Add/Remove Nodes</h3>

            <div class="space-y-4 mb-6">
                <div class="flex gap-4">
                    <button onclick="addProcess()" class="flex-1 py-2 px-4 bg-process-color text-gray-900 font-bold rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
                        Add Process (P<span id="nextPId">1</span>)
                    </button>
                    <button onclick="addResource()" class="flex-1 py-2 px-4 bg-resource-color text-white font-bold rounded-lg hover:bg-emerald-600 transition duration-150 shadow-md">
                        Add Resource (R<span id="nextRId">1</span>)
                    </button>
                </div>
            </div>

            <h3 class="text-xl font-semibold mb-3 text-white border-t border-border-color pt-4">Detailed System State</h3>
            <div id="nodes-list" class="space-y-2 max-h-80 overflow-y-auto scrollable-content text-sm bg-sub-card p-2 rounded-lg border border-border-color">
                <!-- Detailed status and removal buttons will be here -->
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="lg:w-3/5 rag-container p-4 flex flex-col items-center justify-center min-h-[500px] bg-card-dark border border-border-color">
            <svg id="rag-svg" class="w-full h-full" viewBox="0 0 700 480"></svg>
        </div>
    </main>

    <script type="text/javascript">
        // Global state for Processes and Resources
        let processes = {}; // { P1: { id: 'P1', pos: {x, y} }, ... }
        let resources = {}; // { R1: { id: 'R1', pos: {x, y} }, ... }
        let edges = [];     // [{ source: 'P1', target: 'R1', type: 'request'/'allocation' }]

        let nextPId = 1;
        let nextRId = 1;

        // Dragging State
        let selectedNodeId = null;
        let offset = { x: 0, y: 0 };
        const svgElement = document.getElementById('rag-svg');
        
        // Constants for visualization
        const NODE_RADIUS = 25;
        const RES_SIZE = 50;
        const GRID_STEP = 100;
        const SVG_WIDTH = 700;
        const SVG_HEIGHT = 480;
        
        /**
         * Helper to resolve Tailwind color names to their actual hex values using the defined config.
         */
        function resolveColor(colorName) {
            const colors = tailwind.config.theme.extend.colors;
            if (colors[colorName]) return colors[colorName];
            
            // Fallback for standard Tailwind colors used in JS
            switch (colorName) {
                case 'indigo-600': return '#4f46e5';
                case 'emerald-600': return '#059669';
                case 'yellow-500': return '#eab308';
                case 'teal-500': return '#14b8a6';
                case 'red-900': return '#7f1d1d';
                case 'green-900': return '#064e3b';
                case 'red-700': return '#b91c1c';
                case 'green-700': return '#047857';
                case 'green-300': return '#6ee7b7';
                case 'gray-900': return '#111827';
                case 'gray-800': return '#1f2937';
                case 'gray-700': return '#374151';
                case 'slate-700': return '#334155';
                default: return colorName.startsWith('#') ? colorName : 'black';
            }
        }
        
        // --- DRAGGING LOGIC ---

        function getMousePosition(e) {
            // Get the bounding box of the SVG element
            const svgRect = svgElement.getBoundingClientRect();
            
            const x = e.clientX - svgRect.left;
            const y = e.clientY - svgRect.top;
            
            const scaleX = SVG_WIDTH / svgRect.width;
            const scaleY = SVG_HEIGHT / svgRect.height;

            return { x: x * scaleX, y: y * scaleY };
        }

        function startDrag(e) {
            let target = e.target;
            while (target && target.tagName !== 'svg') {
                if (target.getAttribute('data-node-id')) {
                    selectedNodeId = target.getAttribute('data-node-id');
                    
                    const pos = getMousePosition(e);
                    const node = processes[selectedNodeId] || resources[selectedNodeId];
                    
                    offset.x = pos.x - node.pos.x;
                    offset.y = pos.y - node.pos.y;

                    target.style.cursor = 'grabbing';
                    return;
                }
                target = target.parentNode;
            }
            selectedNodeId = null;
        }

        function drag(e) {
            if (!selectedNodeId) return;
            e.preventDefault();

            const pos = getMousePosition(e);
            
            let newX = pos.x - offset.x;
            let newY = pos.y - offset.y;

            const nodeSize = selectedNodeId.startsWith('P') ? NODE_RADIUS : RES_SIZE / 2;
            
            newX = Math.max(nodeSize, Math.min(SVG_WIDTH - nodeSize, newX));
            newY = Math.max(nodeSize, Math.min(SVG_HEIGHT - nodeSize, newY));

            const node = processes[selectedNodeId] || resources[selectedNodeId];
            if (node) {
                node.pos.x = newX;
                node.pos.y = newY;
                renderGraph();
            }
        }

        function endDrag(e) {
            if (selectedNodeId) {
                const draggedNode = document.querySelector(`[data-node-id="${selectedNodeId}"]`);
                if (draggedNode) {
                    draggedNode.style.cursor = 'grab';
                }
            }
            selectedNodeId = null;
        }
        
        // --- CORE ALGORITHMS ---

        /**
         * Runs DFS cycle detection on the current graph state.
         * @returns {Array<string>} List of node IDs involved in a deadlock cycle.
         */
        function detectDeadlock() {
            const visited = {};
            const deadlockedNodes = new Set();
            const graph = buildAdjacencyList();

            function getNeighbors(nodeId) { return graph[nodeId] || []; }

            function dfs(u, path) {
                visited[u] = 1;
                path.push(u);

                const neighbors = getNeighbors(u);
                for (const v of neighbors) {
                    if (visited[v] === 1) { // Cycle detected!
                        const cycleStart = path.indexOf(v);
                        for (let i = cycleStart; i < path.length; i++) {
                            deadlockedNodes.add(path[i]);
                        }
                        return true;
                    }
                    if (visited[v] === 0 || visited[v] === undefined) {
                        if (dfs(v, path)) {
                            return true;
                        }
                    }
                }

                visited[u] = 2;
                path.pop();
                return false;
            }

            const allNodeIds = [...Object.keys(processes), ...Object.keys(resources)];
            allNodeIds.forEach(id => visited[id] = 0);

            allNodeIds.forEach(nodeId => {
                if (visited[nodeId] === 0 || visited[nodeId] === undefined) {
                    dfs(nodeId, []);
                }
            });

            return Array.from(deadlockedNodes);
        }

        /**
         * Builds an adjacency list representation of the RAG.
         */
        function buildAdjacencyList() {
            const adj = {};
            edges.forEach(edge => {
                if (!adj[edge.source]) adj[edge.source] = [];
                adj[edge.source].push(edge.target);
            });
            return adj;
        }

        // --- UTILITY FUNCTIONS ---

        /**
         * Displays a temporary success or error message to the user.
         */
        function displayMessage(message, isError = false) {
            const msgDiv = document.getElementById('action-message');
            msgDiv.textContent = message;
            
            // Resolve colors for the feedback box
            const errorBg = resolveColor('red-900');
            const errorText = resolveColor('deadlock-color');
            const successBg = resolveColor('green-900');
            const successText = resolveColor('green-300');

            if (isError) {
                msgDiv.style.backgroundColor = errorBg;
                msgDiv.style.color = errorText;
                msgDiv.style.opacity = '1';
            } else {
                msgDiv.style.backgroundColor = successBg;
                msgDiv.style.color = successText;
                msgDiv.style.opacity = '1';
            }
            
            // Hide message after 3 seconds
            setTimeout(() => {
                msgDiv.style.opacity = '0';
            }, 3000);
        }

        /**
         * Generates a coordinate for a new node on a grid, attempting to avoid overlaps.
         */
        function getNewNodePosition() {
            const nodes = [...Object.values(processes), ...Object.values(resources)];
            let x, y, overlap;
            const maxAttempts = 100;
            const PADDING = 60; // Minimum distance between nodes

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Generate random coordinates within bounds, snapping to a grid
                x = Math.floor(Math.random() * ((SVG_WIDTH - 2 * PADDING) / GRID_STEP)) * GRID_STEP + PADDING;
                y = Math.floor(Math.random() * ((SVG_HEIGHT - 2 * PADDING) / GRID_STEP)) * GRID_STEP + PADDING;

                overlap = nodes.some(node => {
                    const dx = node.pos.x - x;
                    const dy = node.pos.y - y;
                    return Math.sqrt(dx * dx + dy * dy) < PADDING; 
                });

                if (!overlap) {
                    return { x, y };
                }
            }
            return { x: 50 + Object.keys(processes).length * 50, y: 50 + Object.keys(resources).length * 50 };
        }

        /**
         * Updates the dropdown options with current process and resource IDs.
         */
        function updateDropdowns() {
            const sourceSelect = document.getElementById('source');
            const targetSelect = document.getElementById('target');
            sourceSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            const allNodes = [...Object.keys(processes), ...Object.keys(resources)].sort();
            
            allNodes.forEach(id => {
                const option1 = document.createElement('option');
                option1.value = id;
                option1.textContent = id;
                sourceSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = id;
                option2.textContent = id;
                targetSelect.appendChild(option2);
            });

            if (sourceSelect.options.length > 0) sourceSelect.selectedIndex = 0;
            if (targetSelect.options.length > 1) targetSelect.selectedIndex = 1; 
        }

        /**
         * Calculates and updates simulation metrics and detailed status.
         */
        function updateMetrics(isDeadlocked, deadlockedNodes) {
            const numProcesses = Object.keys(processes).length;
            const numResources = Object.keys(resources).length;
            const numRequests = edges.filter(e => e.type === 'request').length;
            const numAllocations = edges.filter(e => e.type === 'allocation').length;

            const metricsPanel = document.getElementById('metrics-panel');
            metricsPanel.innerHTML = '';
            
            const metrics = [
                { title: 'Processes', value: numProcesses, color: 'process-color' },
                { title: 'Resources', value: numResources, color: 'resource-color' },
                { title: 'Requests (P→R)', value: numRequests, color: 'request-edge' },
                { title: 'Allocations (R→P)', value: numAllocations, color: 'allocation-edge' },
            ];

            metrics.forEach(metric => {
                const tile = document.createElement('div');
                tile.className = `p-3 rounded-lg bg-gray-800 border border-border-color shadow-lg`;
                // Use resolveColor(metric.color) for the text to ensure high contrast
                tile.innerHTML = `
                    <p class="text-sm font-medium text-slate-400">${metric.title}</p>
                    <p class="text-2xl font-bold text-white mt-1" style="color: ${resolveColor(metric.color)};">${metric.value}</p>
                `;
                metricsPanel.appendChild(tile);
            });
            
            // --- Detailed Status Display ---
            let detailedStatusHtml = '';
            const listDiv = document.getElementById('nodes-list');

            const allocationMap = {};
            const requestMap = {};
            const requestedByMap = {};

            edges.forEach(edge => {
                if (edge.type === 'allocation') {
                    if (!allocationMap[edge.source]) allocationMap[edge.source] = [];
                    allocationMap[edge.source].push(edge.target); 
                } else if (edge.type === 'request') {
                    if (!requestMap[edge.source]) requestMap[edge.source] = [];
                    requestMap[edge.source].push(edge.target);
                    
                    if (!requestedByMap[edge.target]) requestedByMap[edge.target] = [];
                    requestedByMap[edge.target].push(edge.source);
                }
            });
            
            [...Object.keys(processes), ...Object.keys(resources)].sort().forEach(id => {
                const isDead = deadlockedNodes.includes(id);
                const baseColor = id.startsWith('P') ? 'text-process-color' : 'text-resource-color';
                const statusColor = isDead ? 'text-deadlock-color' : 'text-slate-400';
                
                let details;
                if (id.startsWith('P')) {
                    const requests = requestMap[id] ? requestMap[id].map(rId => `<span class="text-request-edge font-mono">${rId}</span>`).join(', ') : '<span class="text-slate-500">None</span>';
                    details = `<span class="text-xs text-slate-400">Requests:</span> ${requests}`;
                } else {
                    const allocatedTo = allocationMap[id] ? allocationMap[id].map(pId => `<span class="text-allocation-edge font-mono">${pId}</span>`).join(', ') : '<span class="text-slate-500">None</span>';
                    const requestedBy = requestedByMap[id] ? requestedByMap[id].map(pId => `<span class="text-request-edge font-mono">${pId}</span>`).join(', ') : '<span class="text-slate-500">None</span>';
                    details = `
                        <span class="text-xs text-slate-400">Held By:</span> ${allocatedTo}<br>
                        <span class="text-xs text-slate-400">Waiting:</span> ${requestedBy}
                    `;
                }
                
                // Use bg-sub-card for hover background and border-border-color for internal borders
                detailedStatusHtml += `
                    <div class="flex justify-between items-start p-2 border-b border-border-color hover:bg-sub-card rounded-md transition duration-150">
                        <div class="flex-1">
                            <span class="font-bold ${baseColor}">${id}</span> 
                            <span class="text-xs font-medium ${statusColor}">[${isDead ? 'DEADLOCKED' : id.startsWith('P') ? 'Active' : 'Free'}]</span><br>
                            ${details}
                        </div>
                        <button onclick="removeNode('${id}')" class="flex-shrink-0 text-xs text-red-400 hover:text-red-300 transition duration-150 py-1 px-2 rounded-full border border-red-400 hover:border-red-300">
                            X
                        </button>
                    </div>
                `;
            });
            
            listDiv.innerHTML = detailedStatusHtml || '<p class="text-slate-500 p-2">Add Processes and Resources to begin simulation.</p>';
        }


        // --- CRUD OPERATIONS ---

        function addProcess() {
            const id = 'P' + nextPId++;
            const pos = getNewNodePosition();
            processes[id] = { id, pos };
            document.getElementById('nextPId').textContent = nextPId;
            renderGraph();
        }

        function addResource() {
            const id = 'R' + nextRId++;
            const pos = getNewNodePosition();
            resources[id] = { id, pos };
            document.getElementById('nextRId').textContent = nextRId;
            renderGraph();
        }

        function removeNode(id) {
            if (id.startsWith('P')) {
                delete processes[id];
            } else if (id.startsWith('R')) {
                delete resources[id];
            }
            edges = edges.filter(e => e.source !== id && e.target !== id);
            renderGraph();
        }

        function createEdge(type) {
            const sourceId = document.getElementById('source').value;
            const targetId = document.getElementById('target').value;

            if (!sourceId || !targetId) {
                displayMessage("Please select both source and target nodes.", true);
                return;
            }

            if (type === 'request' && (!sourceId.startsWith('P') || !targetId.startsWith('R'))) {
                displayMessage("Error: Request must be Process (P) to Resource (R).", true);
                return;
            }
            if (type === 'allocation' && (!sourceId.startsWith('R') || !targetId.startsWith('P'))) {
                displayMessage("Error: Allocation must be Resource (R) to Process (P).", true);
                return;
            }

            const existingEdge = edges.find(e => e.source === sourceId && e.target === targetId);
            if (existingEdge) {
                displayMessage("Error: This exact edge already exists.", true);
                return;
            } 

            edges.push({ source: sourceId, target: targetId, type: type });
            displayMessage(`Success! Added ${sourceId} → ${targetId} (${type}).`, false);
            renderGraph();
        }

        function createRequest() { createEdge('request'); }
        function createAllocation() { createEdge('allocation'); }

        function removeEdge() {
            const sourceId = document.getElementById('source').value;
            const targetId = document.getElementById('target').value;
            
            if (!sourceId || !targetId) {
                displayMessage("Please select both source and target nodes to remove an edge.", true);
                return;
            }

            const initialLength = edges.length;
            
            edges = edges.filter(e => !(e.source === sourceId && e.target === targetId));

            if (edges.length < initialLength) {
                displayMessage(`Success! Removed edge between ${sourceId} and ${targetId}.`, false);
                renderGraph();
            } else {
                displayMessage(`Error: No edge found between ${sourceId} and ${targetId}.`, true);
            }
        }

        // --- RENDERING FUNCTIONS ---

        /**
         * Main function to re-render the entire visualization.
         */
        function renderGraph() {
            const svg = document.getElementById('rag-svg');
            svg.innerHTML = ''; // Clear SVG contents

            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.appendChild(defs);

            const deadlockedNodes = detectDeadlock();
            const isDeadlocked = deadlockedNodes.length > 0;

            updateStatus(isDeadlocked, deadlockedNodes);
            updateMetrics(isDeadlocked, deadlockedNodes);
            updateDropdowns();

            // 1. Render Edges (must be before nodes)
            edges.forEach(edge => {
                const sourceNode = processes[edge.source] || resources[edge.source];
                const targetNode = processes[edge.target] || resources[edge.target];
                if (!sourceNode || !targetNode) return;

                const isDeadlockedEdge = deadlockedNodes.includes(edge.source) && deadlockedNodes.includes(edge.target);

                drawEdge(svg, sourceNode, targetNode, edge.type, isDeadlockedEdge, defs);
            });

            // 2. Render Nodes (Processes and Resources)
            Object.values(processes).forEach(p => {
                const isDeadlocked = deadlockedNodes.includes(p.id);
                drawProcess(svg, p.pos, p.id, isDeadlocked);
            });

            Object.values(resources).forEach(r => {
                const isDeadlocked = deadlockedNodes.includes(r.id);
                drawResource(svg, r.pos, r.id, isDeadlocked);
            });
        }

        /**
         * Draws an arrowed edge between two points.
         */
        function drawEdge(svg, sourceNode, targetNode, type, isDeadlocked, defs) {
            const start = sourceNode.pos;
            const end = targetNode.pos;
            
            let strokeColor, strokeWidth, markerColor;

            if (isDeadlocked) {
                strokeColor = resolveColor('deadlock-color');
                strokeWidth = 4;
                markerColor = resolveColor('deadlock-color');
            } else if (type === 'request') {
                strokeColor = resolveColor('request-edge');
                strokeWidth = 3;
                markerColor = resolveColor('request-edge');
            } else { // allocation
                strokeColor = resolveColor('allocation-edge');
                strokeWidth = 3;
                markerColor = resolveColor('allocation-edge');
            }

            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const angle = Math.atan2(dy, dx);

            const startOffset = sourceNode.id.startsWith('P') ? NODE_RADIUS : RES_SIZE / 2;
            const endOffset = targetNode.id.startsWith('P') ? NODE_RADIUS : RES_SIZE / 2;

            const startX = start.x + Math.cos(angle) * startOffset;
            const startY = start.y + Math.sin(angle) * startOffset;
            
            const endX = end.x - Math.cos(angle) * (endOffset + 5); 
            const endY = end.y - Math.sin(angle) * (endOffset + 5);

            // Define arrowhead marker
            const markerId = `arrowhead-${markerColor.replace(/#/g, '')}`;
            if (!document.getElementById(markerId)) {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '10');
                marker.setAttribute('refX', '7');
                marker.setAttribute('refY', '5');
                marker.setAttribute('orient', 'auto-start-reverse');
                marker.innerHTML = `<path d="M 0 0 L 10 5 L 0 10 z" fill="${markerColor}" />`;
                defs.appendChild(marker);
            }

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', strokeColor);
            line.setAttribute('stroke-width', strokeWidth);
            line.setAttribute('marker-end', `url(#${markerId})`);
            line.classList.add('edge-path');
            svg.appendChild(line);
        }

        /**
         * Draws a Process node (Circle) using a draggable group.
         */
        function drawProcess(svg, pos, id, isDeadlocked) {
            const color = isDeadlocked ? 'deadlock-color' : 'process-color';
            const nodeColor = resolveColor(color);
            // Stronger border color for high contrast
            const strokeColor = isDeadlocked ? nodeColor : resolveColor('sub-card'); 

            // Draggable Group
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('data-node-id', id);
            g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
            g.style.cursor = selectedNodeId === id ? 'grabbing' : 'grab'; // Set cursor
            svg.appendChild(g);

            // Circle (relative to 0,0) - Increased stroke width
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', NODE_RADIUS);
            circle.setAttribute('fill', nodeColor);
            circle.setAttribute('stroke', strokeColor);
            circle.setAttribute('stroke-width', isDeadlocked ? 7 : 4); // Stronger border
            g.appendChild(circle);

            // Text Label (relative to 0,0)
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 5);
            // Use black text for high contrast on the light process node, but keep white for deadlocked (red) nodes.
            text.setAttribute('fill', isDeadlocked ? 'white' : 'black');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-weight', 'bold');
            text.textContent = id;
            g.appendChild(text);
        }

        /**
         * Draws a Resource node (Square) using a draggable group.
         */
        function drawResource(svg, pos, id, isDeadlocked) {
            const color = isDeadlocked ? 'deadlock-color' : 'resource-color';
            const nodeColor = resolveColor(color);
            // Stronger border color for high contrast
            const strokeColor = isDeadlocked ? nodeColor : resolveColor('sub-card'); 
            const halfSize = RES_SIZE / 2;

            // Draggable Group
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('data-node-id', id);
            g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
            g.style.cursor = selectedNodeId === id ? 'grabbing' : 'grab'; // Set cursor
            svg.appendChild(g);

            // Rectangle (relative to 0,0) - Increased stroke width
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', -halfSize);
            rect.setAttribute('y', -halfSize);
            rect.setAttribute('width', RES_SIZE);
            rect.setAttribute('height', RES_SIZE);
            rect.setAttribute('rx', 8);
            rect.setAttribute('ry', 8);
            rect.setAttribute('fill', nodeColor);
            rect.setAttribute('stroke', strokeColor);
            rect.setAttribute('stroke-width', isDeadlocked ? 7 : 4); // Stronger border
            g.appendChild(rect);

            // Text Label (relative to 0,0)
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 5);
            text.setAttribute('fill', 'white');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-weight', 'bold');
            text.textContent = id;
            g.appendChild(text);
        }

        /**
         * Updates the deadlock status display.
         */
        function updateStatus(isDeadlocked, deadlockedNodes) {
            const statusDiv = document.getElementById('deadlock-status');
            const deadlockColor = resolveColor('deadlock-color');
            const green300 = resolveColor('green-300');
            
            if (isDeadlocked) {
                statusDiv.classList.remove('bg-green-900', 'text-green-300', 'border-green-700');
                statusDiv.classList.add('bg-red-900', 'border-red-700');
                statusDiv.style.color = deadlockColor;
                statusDiv.style.borderColor = resolveColor('red-700');
                statusDiv.innerHTML = `
                    System Status: <span class="font-extrabold text-white">DEADLOCK DETECTED!</span><br>
                    <span class="text-sm font-normal" style="color: ${deadlockColor};">Involved Nodes: ${deadlockedNodes.join(', ')}</span>
                `;
            } else {
                statusDiv.classList.remove('bg-red-900', 'border-deadlock-color');
                statusDiv.classList.add('bg-green-900', 'text-green-300', 'border-green-700');
                statusDiv.style.color = green300;
                statusDiv.style.borderColor = resolveColor('green-700');
                statusDiv.textContent = 'System Status: SAFE (No Deadlock)';
            }
        }

        // --- INITIALIZATION ---

        window.onload = () => {
            // Attach global drag listeners
            svgElement.addEventListener('mousedown', startDrag);
            svgElement.addEventListener('mousemove', drag);
            svgElement.addEventListener('mouseup', endDrag);
            svgElement.addEventListener('mouseleave', endDrag);

            // Initial Nodes
            addProcess();
            addProcess();
            addResource();
            addResource();
            
            // Start with an empty edge list, requiring user interaction to create connections.

            renderGraph();
        };

    </script>
</body>
</html>